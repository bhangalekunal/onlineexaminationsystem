import { EventEmitter, Component, ChangeDetectionStrategy, Output, Input, ElementRef, ChangeDetectorRef, HostBinding, ContentChildren, Optional, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

class SidebarSettingsComponent {
    constructor() {
        this.modeChange = new EventEmitter();
        this.positionChange = new EventEmitter();
    }
    get position() {
        return this._position;
    }
    ;
    set position(value) {
        this._position = value;
        this.positionChange.emit(this);
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        this._mode = value;
        this.modeChange.emit(this);
    }
}
SidebarSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar-settings',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SidebarSettingsComponent.propDecorators = {
    modeChange: [{ type: Output }],
    positionChange: [{ type: Output }],
    position: [{ type: Input }],
    mode: [{ type: Input }]
};

class SidebarAccordionComponent {
    constructor(element, cdRef) {
        this.element = element;
        this.cdRef = cdRef;
        this.classNameSidebarAccordion = true;
        this.sidebarResizableBegin = new EventEmitter();
        this.sidebarResizableEnd = new EventEmitter();
        this.sidebarOpenedChange = new EventEmitter();
        this._sidebars = [];
        this.onMouseMove = (e) => {
            if (!this._resizeSidebar) {
                return;
            }
            const root = document.documentElement;
            const getDiffPositionValue = () => {
                switch (this._resizeSidebar.position) {
                    case 'left':
                        return e.clientX - this._resizeSidebar.mouseClientX;
                    case 'right':
                        return (e.clientX - this._resizeSidebar.mouseClientX) * -1;
                    case 'top':
                        return e.clientY - this._resizeSidebar.mouseClientY;
                    case 'bottom':
                        return (e.clientY - this._resizeSidebar.mouseClientY) * -1;
                    default:
                        return 0;
                }
            };
            let positionValue = getDiffPositionValue() + this._resizeSidebar.spaceContent;
            if (positionValue < 0) {
                positionValue = 0;
            }
            root.style.setProperty(`--ng-sidebar-accordion-space__sidebar-content-${this._resizeSidebar.position}`, positionValue + 'px');
            this.correctMaxSizeSidebars();
        };
        this.onMouseUp = () => {
            if (this._resizeSidebar) {
                const position = this._resizeSidebar.position;
                delete this._resizeSidebar;
                this.sidebarResizableEnd.emit(position);
            }
        };
        this.groupBy = (xs, key) => {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };
    }
    ngAfterViewInit() {
        const groupSettings = this.groupBy(this.sideBarSettingsList.toArray(), 'position');
        Object.keys(groupSettings)
            .forEach(key => {
            if (groupSettings[key].length > 1) {
                throw new Error('<ng-sidebar-settings> ng-sidebar-settings can\'t be more than one with the same position.');
            }
        });
        this.sidebarSettingsSubscribe();
    }
    ngOnInit() {
        window.addEventListener('mousemove', this.onMouseMove);
        window.addEventListener('mouseup', this.onMouseUp);
    }
    ngOnDestroy() {
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        this.sidebarUnsubscribe();
        this.sidebarSettingsUnsubscribe();
    }
    _addSidebar(sidebar) {
        this._sidebars.push(sidebar);
        this.sidebarSubscribe(sidebar);
    }
    _removeSidebar(sidebar) {
        const index = this._sidebars.indexOf(sidebar);
        if (index !== -1) {
            this._sidebars.splice(index, 1);
        }
    }
    _isResizableGutter(position) {
        if (!position || !this.sidebarResizable) {
            return false;
        }
        const groupByPosition = this.groupBy(this._sidebars, 'position');
        if (groupByPosition.hasOwnProperty(position)) {
            return !!groupByPosition[position].find(s => s.opened);
        }
        return false;
    }
    _getClassName(position) {
        const sideBarSettings = this.sideBarSettingsList.filter(s => s.position === position);
        return `ng-sidebar-accordion__${position}-pane${(this._resizeSidebar && this._resizeSidebar.position === position
            ?
                ` ng-sidebar-accordion__${position}-pane_resizable`
            : '')}${(sideBarSettings.length > 0 && sideBarSettings[0].mode === 'over'
            ? ` ng-sidebar-accordion__${position}-pane_over`
            : '')}`;
    }
    _getStyle(position) {
        const root = document.documentElement;
        const spaceSidebarHeader = +getComputedStyle(root)
            .getPropertyValue(`--ng-sidebar-accordion-space__sidebar-header`)
            .replace('px', '');
        const spaceSidebarHeaderBorder = +getComputedStyle(root)
            .getPropertyValue(`--ng-sidebar-accordion-space__sidebar-header-border`)
            .replace('px', '');
        const leftPaneIsOver = this.sideBarSettingsList.filter(s => s.position === 'left' && s.mode === 'over').length > 0;
        const topPaneIsOver = this.sideBarSettingsList.filter(s => s.position === 'top' && s.mode === 'over').length > 0;
        const rightPaneIsOver = this.sideBarSettingsList.filter(s => s.position === 'right' && s.mode === 'over').length > 0;
        const bottomPaneIsOver = this.sideBarSettingsList.filter(s => s.position === 'bottom' && s.mode === 'over').length > 0;
        const leftSidebarCount = this._sidebars.filter(s => s.position === 'left' && s._headersLength > 0).length;
        const topSidebarCount = this._sidebars.filter(s => s.position === 'top' && s._headersLength > 0).length;
        const rightSidebarCount = this._sidebars.filter(s => s.position === 'right' && s._headersLength > 0).length;
        const bottomSidebarCount = this._sidebars.filter(s => s.position === 'bottom' && s._headersLength > 0).length;
        let style = {};
        switch (position) {
            case 'top':
            case 'bottom':
                const currentPaneIsOver = this.sideBarSettingsList.filter(s => s.position === position && s.mode === 'over').length > 0;
                if (currentPaneIsOver) {
                    if (leftPaneIsOver) {
                        style.left = leftSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                    }
                    else {
                        style.left = '0';
                    }
                    if (rightPaneIsOver) {
                        style.right = rightSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                    }
                    else {
                        style.right = '0';
                    }
                    return style;
                }
                else {
                    if (leftPaneIsOver) {
                        style.paddingLeft = leftSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                    }
                    if (rightPaneIsOver) {
                        style.paddingRight = rightSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                    }
                    return style;
                }
            case undefined:
            case null:
                if (leftPaneIsOver) {
                    style.paddingLeft = leftSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                }
                if (topPaneIsOver) {
                    style.paddingTop = topSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                }
                if (rightPaneIsOver) {
                    style.paddingRight = rightSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                }
                if (bottomPaneIsOver) {
                    style.paddingBottom = bottomSidebarCount * spaceSidebarHeader + spaceSidebarHeaderBorder + 'px';
                }
                return style;
            default:
                return null;
        }
    }
    _onSidebarResizeBegin(position, e) {
        const root = document.documentElement;
        this._resizeSidebar = {
            position,
            mouseClientX: e.clientX,
            mouseClientY: e.clientY,
            spaceContent: +getComputedStyle(root)
                .getPropertyValue(`--ng-sidebar-accordion-space__sidebar-content-${position}`)
                .replace('px', '')
        };
        this.sidebarResizableBegin.emit(position);
    }
    open(value, index = 0) {
        this.sidebarToggle(value, index, true);
    }
    close(value) {
        this.sidebarToggle(value, null, false);
    }
    getSidebarIndex(sidebar) {
        if (!sidebar) {
            return -1;
        }
        const groupByPosition = this.groupBy(this._sidebars, 'position');
        if (groupByPosition.hasOwnProperty('left')) {
            groupByPosition['left'].reverse();
        }
        if (groupByPosition.hasOwnProperty('top')) {
            groupByPosition['top'].reverse();
        }
        if (groupByPosition.hasOwnProperty(sidebar.position)) {
            return groupByPosition[sidebar.position].findIndex(s => s === sidebar);
        }
        return -1;
    }
    sidebarToggle(position, index, opened) {
        const groupByPosition = this.groupBy(this._sidebars, 'position');
        if (groupByPosition.hasOwnProperty('left')) {
            groupByPosition['left'].reverse();
        }
        if (groupByPosition.hasOwnProperty('top')) {
            groupByPosition['top'].reverse();
        }
        switch (position) {
            case 'all':
                Object.keys(groupByPosition).forEach(key => {
                    opened
                        ? groupByPosition[key][index].open()
                        : index
                            ? groupByPosition[key][index].close()
                            : groupByPosition[key].forEach(s => s.close());
                });
                break;
            default:
                opened
                    ? groupByPosition[position][index].open()
                    : index
                        ? groupByPosition[position][index].close()
                        : groupByPosition[position].forEach(s => s.close());
                break;
        }
    }
    correctMaxSizeSidebars() {
        const setSpaceSidebar = (openedSidebars, outOfScreenSize) => {
            openedSidebars.forEach(s => {
                let spaceSidebar = +getComputedStyle(root)
                    .getPropertyValue(`--ng-sidebar-accordion-space__sidebar-content-${s.position}`)
                    .replace('px', '');
                if (spaceSidebar < 0) {
                    spaceSidebar *= -1;
                }
                let spaceValue = spaceSidebar - outOfScreenSize;
                if (spaceValue < 0) {
                    spaceValue = 0;
                }
                root.style.setProperty(`--ng-sidebar-accordion-space__sidebar-content-${s.position}`, spaceValue + 'px');
            });
        };
        const root = document.documentElement;
        const spaceSidebarHeaderBorder = +getComputedStyle(root)
            .getPropertyValue(`--ng-sidebar-accordion-space__sidebar-header-border`)
            .replace('px', '');
        const outOfScreenWidth = this.element.nativeElement.scrollWidth - (this.element.nativeElement.clientWidth + spaceSidebarHeaderBorder);
        const outOfScreenHeight = this.element.nativeElement.scrollHeight - (this.element.nativeElement.clientHeight + spaceSidebarHeaderBorder);
        if (outOfScreenWidth > 0) {
            const openedSidebarsW = this._sidebars
                .filter(s => (s.position === 'left' || s.position === 'right') && s.opened
                && !this.sideBarSettingsList.find(ss => ss.position === s.position && ss.mode === 'over'));
            setSpaceSidebar(openedSidebarsW, outOfScreenWidth);
        }
        if (outOfScreenHeight > 0) {
            const openedSidebarsH = this._sidebars
                .filter(s => (s.position === 'top' || s.position === 'bottom') && s.opened
                && !this.sideBarSettingsList.find(ss => ss.position === s.position && ss.mode === 'over'));
            setSpaceSidebar(openedSidebarsH, outOfScreenHeight);
        }
    }
    sidebarSubscribe(sidebar) {
        sidebar.headerClicked.subscribe((e) => {
            e.opened ? e.close() : e.open();
        });
        sidebar.headerTouchMoved.subscribe((e) => {
            const isAllowResizable = this._sidebars
                .filter(s => s.position === e.sender.position && s.opened).length > 0;
            if (this.sidebarResizable && isAllowResizable) {
                const groupByPosition = this.groupBy(this._sidebars, 'position');
                if (groupByPosition.hasOwnProperty('left')) {
                    groupByPosition['left'].reverse();
                }
                if (groupByPosition.hasOwnProperty('top')) {
                    groupByPosition['top'].reverse();
                }
                // move only first sidebar
                if (e.sender === groupByPosition[e.sender.position][0]) {
                    if (!this._resizeSidebar) {
                        this._onSidebarResizeBegin(e.sender.position, {
                            clientX: e.originalEvent.touches[0].clientX,
                            clientY: e.originalEvent.touches[0].clientY
                        });
                    }
                    else {
                        this.onMouseMove({
                            clientX: e.originalEvent.touches[0].clientX,
                            clientY: e.originalEvent.touches[0].clientY
                        });
                    }
                }
            }
        });
        sidebar.headerTouchEnded.subscribe((e) => {
            if (this._resizeSidebar) {
                this.onMouseUp();
            }
            else {
                e.sender.opened ? e.sender.close() : e.sender.open();
            }
        });
        sidebar.openedChange.subscribe((e) => {
            if (e.opened) {
                this._sidebars.filter(s => s.opened && s != e.sender &&
                    s.position === e.sender.position).forEach(s => s.close());
            }
            this.cdRef.markForCheck();
            const root = document.documentElement;
            const animationDuration = +getComputedStyle(root)
                .getPropertyValue(`--ng-sidebar-accordion-animation-duration`)
                .replace('s', '');
            setTimeout(() => this.correctMaxSizeSidebars(), 1000 * animationDuration);
            this.sidebarOpenedChange.emit(e.sender);
        });
    }
    sidebarUnsubscribe() {
        this._sidebars.forEach(sidebar => {
            sidebar.headerClicked.unsubscribe();
            sidebar.openedChange.unsubscribe();
            sidebar.headerTouchMoved.unsubscribe();
            sidebar.headerTouchEnded.unsubscribe();
        });
    }
    sidebarSettingsSubscribe() {
        this.sideBarSettingsList.forEach(s => {
            s.modeChange.subscribe(() => {
                this.cdRef.markForCheck();
            });
            s.positionChange.subscribe(() => {
                this.cdRef.markForCheck();
            });
        });
    }
    sidebarSettingsUnsubscribe() {
        this.sideBarSettingsList.forEach(s => {
            s.modeChange.unsubscribe();
            s.positionChange.unsubscribe();
        });
    }
}
SidebarAccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar-accordion',
                template: `
    <div [ngClass]="_getClassName('left')" [ngStyle]="_getStyle('left')">
      <div
        *ngIf="_isResizableGutter('left')"
        class="ng-sidebar-accordion__gutter-vertical"
        (mousedown)="_onSidebarResizeBegin('left', $event)"
      >
      </div>
      <ng-content select="ng-sidebar[position=left]"></ng-content>
    </div>
    <div [ngClass]="_getClassName('top')" [ngStyle]="_getStyle('top')">
      <div
        *ngIf="_isResizableGutter('top')"
        class="ng-sidebar-accordion__gutter-horizontal"
        (mousedown)="_onSidebarResizeBegin('top', $event)"
      >
      </div>
      <ng-content select="ng-sidebar[position=top]"></ng-content>
    </div>
    <div [ngClass]="_getClassName('right')" [ngStyle]="_getStyle('right')">
      <div
        *ngIf="_isResizableGutter('right')"
        class="ng-sidebar-accordion__gutter-vertical"
        (mousedown)="_onSidebarResizeBegin('right', $event)"
      >
      </div>
      <ng-content select="ng-sidebar[position=right]"></ng-content>
    </div>
    <div class="ng-sidebar-accordion__content-pane" [ngStyle]="_getStyle()">
      <ng-content select="ng-sidebar-accordion-content"></ng-content>
    </div>
    <div [ngClass]="_getClassName('bottom')" [ngStyle]="_getStyle('bottom')">
      <div
        *ngIf="_isResizableGutter('bottom')"
        class="ng-sidebar-accordion__gutter-horizontal"
        (mousedown)="_onSidebarResizeBegin('bottom', $event)"
      >
      </div>
      <ng-content select="ng-sidebar[position=bottom]"></ng-content>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["::ng-deep.ng-sidebar-accordion .ng-sidebar-header,::ng-deep.ng-sidebar-accordion__bottom-pane,::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar,::ng-deep.ng-sidebar-accordion__content-pane,::ng-deep.ng-sidebar-accordion__left-pane,::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar,::ng-deep.ng-sidebar-accordion__right-pane,::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar,::ng-deep.ng-sidebar-accordion__top-pane,::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar{display:flex;flex-wrap:nowrap;position:relative}::ng-deep:root{--ng-sidebar-accordion-animation-duration:0.5s;--ng-sidebar-accordion-color-bg:#fff;--ng-sidebar-accordion-color__sidebar-header:#fff;--ng-sidebar-accordion-color__sidebar-header-bg:#337ab7;--ng-sidebar-accordion-space__sidebar-content-bottom:300px;--ng-sidebar-accordion-space__sidebar-content-left:300px;--ng-sidebar-accordion-space__sidebar-content-right:300px;--ng-sidebar-accordion-space__sidebar-content-top:300px;--ng-sidebar-accordion-space__sidebar-gutter:10px;--ng-sidebar-accordion-space__sidebar-header:40px;--ng-sidebar-accordion-space__sidebar-header-border:2px}::ng-deep.ng-sidebar-accordion{background-color:var(--ng-sidebar-accordion-color-bg);display:grid;grid-template-areas:\"left-pane top-pane right-pane\" \"left-pane content-pane right-pane\" \"left-pane bottom-pane right-pane\";grid-template-columns:auto 1fr auto;grid-template-rows:auto 1fr auto;height:100%;overflow:hidden;position:relative;width:100%}::ng-deep.ng-sidebar-accordion__left-pane{-ms-grid-column:1;-ms-grid-row:1;-ms-grid-row-span:3;grid-area:left-pane;margin-left:calc(var(--ng-sidebar-accordion-space__sidebar-header-border)*-1)}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar-header{border-left:var(--ng-sidebar-accordion-space__sidebar-header-border) solid var(--ng-sidebar-accordion-color-bg)}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar{flex-direction:row-reverse}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar_opened .ng-sidebar-content{max-width:var(--ng-sidebar-accordion-space__sidebar-content-left);width:var(--ng-sidebar-accordion-space__sidebar-content-left)}::ng-deep.ng-sidebar-accordion__left-pane ::ng-deep.ng-sidebar-accordion__gutter-vertical{right:0}::ng-deep.ng-sidebar-accordion__left-pane_over{box-shadow:10px 0 50px -15px rgba(0,0,0,.4);position:absolute;z-index:2}::ng-deep.ng-sidebar-accordion__top-pane{-ms-grid-column:2;-ms-grid-row:1;flex-direction:column;grid-area:top-pane;margin-top:calc(var(--ng-sidebar-accordion-space__sidebar-header-border)*-1);width:auto!important}::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar-header{border-top:var(--ng-sidebar-accordion-space__sidebar-header-border) solid var(--ng-sidebar-accordion-color-bg)}::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar{flex-direction:column-reverse}::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar_opened .ng-sidebar-content{height:var(--ng-sidebar-accordion-space__sidebar-content-top);max-height:var(--ng-sidebar-accordion-space__sidebar-content-top)}::ng-deep.ng-sidebar-accordion__top-pane ::ng-deep.ng-sidebar-accordion__gutter-horizontal{bottom:0}::ng-deep.ng-sidebar-accordion__top-pane_over{box-shadow:0 10px 50px -15px rgba(0,0,0,.4);position:absolute;z-index:1}::ng-deep.ng-sidebar-accordion__right-pane{-ms-grid-column:3;-ms-grid-row:1;-ms-grid-row-span:3;grid-area:right-pane;margin-right:calc(var(--ng-sidebar-accordion-space__sidebar-header-border)*-1)}::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar-header{border-right:var(--ng-sidebar-accordion-space__sidebar-header-border) solid var(--ng-sidebar-accordion-color-bg)}::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar_opened .ng-sidebar-content{max-width:var(--ng-sidebar-accordion-space__sidebar-content-right);width:var(--ng-sidebar-accordion-space__sidebar-content-right)}::ng-deep.ng-sidebar-accordion__right-pane_over{box-shadow:-10px 0 50px -15px rgba(0,0,0,.4);position:absolute;right:0;z-index:2}::ng-deep.ng-sidebar-accordion__bottom-pane{-ms-grid-column:2;-ms-grid-row:3;flex-direction:column;grid-area:bottom-pane;margin-bottom:calc(var(--ng-sidebar-accordion-space__sidebar-header-border)*-1);width:auto!important}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar-header{border-bottom:var(--ng-sidebar-accordion-space__sidebar-header-border) solid var(--ng-sidebar-accordion-color-bg)}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar{flex-direction:column}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar_opened .ng-sidebar-content{height:var(--ng-sidebar-accordion-space__sidebar-content-bottom);max-height:var(--ng-sidebar-accordion-space__sidebar-content-bottom)}::ng-deep.ng-sidebar-accordion__bottom-pane_over{bottom:0;box-shadow:0 -10px 50px -15px rgba(0,0,0,.4);position:absolute;z-index:1}::ng-deep.ng-sidebar-accordion__content-pane{-ms-grid-column:2;-ms-grid-row:2;bottom:0;flex-direction:column;grid-area:content-pane;left:0;overflow:auto;position:absolute;right:0;top:0}::ng-deep.ng-sidebar-accordion__bottom-pane,::ng-deep.ng-sidebar-accordion__top-pane{background-color:var(--ng-sidebar-accordion-color-bg);width:100%}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar_opened .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar_opened .ng-sidebar-content{transition:height var(--ng-sidebar-accordion-animation-duration)}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar-header,::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar-header{align-items:center;height:var(--ng-sidebar-accordion-space__sidebar-header);justify-content:center}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar-header__wrapper,::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar-header__wrapper{white-space:nowrap}::ng-deep.ng-sidebar-accordion__bottom-pane .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__top-pane .ng-sidebar-content{height:0;overflow:hidden;transition:height var(--ng-sidebar-accordion-animation-duration)}::ng-deep.ng-sidebar-accordion__left-pane,::ng-deep.ng-sidebar-accordion__right-pane{background-color:var(--ng-sidebar-accordion-color-bg);height:100%}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar_opened .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar_opened .ng-sidebar-content{transition:width var(--ng-sidebar-accordion-animation-duration)}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar-header__content,::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar-header__content{align-self:center;width:var(--ng-sidebar-accordion-space__sidebar-header)}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar-header__wrapper,::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar-header__wrapper{transform:rotate(270deg);white-space:nowrap}::ng-deep.ng-sidebar-accordion__left-pane .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__right-pane .ng-sidebar-content{overflow:hidden;transition:width var(--ng-sidebar-accordion-animation-duration);width:0}::ng-deep.ng-sidebar-accordion__bottom-pane_resizable .ng-sidebar_opened .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__left-pane_resizable .ng-sidebar_opened .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__right-pane_resizable .ng-sidebar_opened .ng-sidebar-content,::ng-deep.ng-sidebar-accordion__top-pane_resizable .ng-sidebar_opened .ng-sidebar-content{transition:none}::ng-deep.ng-sidebar-accordion .ng-sidebar-header{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;background-color:var(--ng-sidebar-accordion-color__sidebar-header-bg);color:var(--ng-sidebar-accordion-color__sidebar-header);cursor:pointer;user-select:none}::ng-deep.ng-sidebar-accordion__gutter-vertical{cursor:col-resize;height:100%;width:var(--ng-sidebar-accordion-space__sidebar-gutter)}::ng-deep.ng-sidebar-accordion__gutter-horizontal,::ng-deep.ng-sidebar-accordion__gutter-vertical{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;position:absolute;user-select:none;z-index:1}::ng-deep.ng-sidebar-accordion__gutter-horizontal{cursor:row-resize;height:var(--ng-sidebar-accordion-space__sidebar-gutter);width:100%}"]
            },] }
];
SidebarAccordionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
SidebarAccordionComponent.propDecorators = {
    classNameSidebarAccordion: [{ type: HostBinding, args: ['class.ng-sidebar-accordion',] }],
    width: [{ type: Input }, { type: HostBinding, args: ['style.width',] }],
    height: [{ type: Input }, { type: HostBinding, args: ['style.height',] }],
    className: [{ type: Input }, { type: HostBinding, args: ['class',] }],
    sidebarResizable: [{ type: Input }],
    sidebarResizableBegin: [{ type: Output }],
    sidebarResizableEnd: [{ type: Output }],
    sidebarOpenedChange: [{ type: Output }],
    sideBarSettingsList: [{ type: ContentChildren, args: [SidebarSettingsComponent,] }]
};

class SidebarComponent {
    constructor(_container) {
        this._container = _container;
        this.classNameSidebar = true;
        this.headerClicked = new EventEmitter();
        this.headerTouchMoved = new EventEmitter();
        this.headerTouchEnded = new EventEmitter();
        this.openedChange = new EventEmitter();
        this.classNameSidebarOpened = false;
        this._headers = [];
        this._contents = [];
        this._opened = false;
        if (!this._container) {
            throw new Error('<ng-sidebar-accordion> must be inside a <ng-sidebar-accordion></ng-sidebar-accordion>.');
        }
    }
    get opened() {
        return this._opened;
    }
    ;
    set opened(value) {
        if (this._opened !== value) {
            this._opened = value;
            this.classNameSidebarOpened = value;
            this.openedChange.emit({ sender: this, opened: value });
        }
    }
    get _headersLength() {
        return this._headers.length;
    }
    get _contentsLength() {
        return this._contents.length;
    }
    ngOnInit() {
        this._container._addSidebar(this);
    }
    ngOnDestroy() {
        this._container._removeSidebar(this);
        this.unsubscribe();
    }
    _addHeader(header) {
        if (this._headersLength > 0) {
            throw new Error('<ng-sidebar-header> must be only one.');
        }
        this._headers.push(header);
        this.subscribe(header);
    }
    _removeHeader(header) {
        const index = this._headers.indexOf(header);
        if (index !== -1) {
            this._headers.splice(index, 1);
        }
    }
    _addContent(content) {
        if (this._contentsLength > 0) {
            throw new Error('<ng-sidebar-content> must be only one.');
        }
        this._contents.push(content);
    }
    _removeContent(content) {
        const index = this._contents.indexOf(content);
        if (index !== -1) {
            this._contents.splice(index, 1);
        }
    }
    open() {
        this.opened = true;
    }
    close() {
        this.opened = false;
    }
    subscribe(header) {
        header.clicked.subscribe(() => {
            this.headerClicked.emit(this);
        });
        header.touchMoved.subscribe(e => {
            this.headerTouchMoved.emit({ sender: this, originalEvent: e });
        });
        header.touchEnded.subscribe(e => {
            this.headerTouchEnded.emit({ sender: this, originalEvent: e });
        });
    }
    unsubscribe() {
        this._headers.forEach(header => {
            header.clicked.unsubscribe();
            header.touchMoved.unsubscribe();
            header.touchEnded.unsubscribe();
        });
    }
}
SidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar',
                template: `
    <ng-content select="ng-sidebar-header, [ng-sidebar-header]"></ng-content>
    <ng-content select="ng-sidebar-content, [ng-sidebar-content]"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SidebarComponent.ctorParameters = () => [
    { type: SidebarAccordionComponent, decorators: [{ type: Optional }] }
];
SidebarComponent.propDecorators = {
    position: [{ type: Input }, { type: HostBinding, args: ['attr.position',] }],
    classNameSidebar: [{ type: Input }, { type: HostBinding, args: ['class.ng-sidebar',] }],
    className: [{ type: Input }, { type: HostBinding, args: ['class',] }],
    style: [{ type: Input }, { type: HostBinding, args: ['style',] }],
    headerClicked: [{ type: Output }],
    headerTouchMoved: [{ type: Output }],
    headerTouchEnded: [{ type: Output }],
    openedChange: [{ type: Output }],
    classNameSidebarOpened: [{ type: HostBinding, args: ['class.ng-sidebar_opened',] }],
    opened: [{ type: Input }]
};

class SidebarHeaderComponent {
    constructor(_container) {
        this._container = _container;
        this.classNameSidebarHeader = true;
        this.clicked = new EventEmitter();
        this.touchMoved = new EventEmitter();
        this.touchEnded = new EventEmitter();
        if (!this._container) {
            throw new Error('<ng-sidebar-header> must be inside a <ng-sidebar></ng-sidebar>.');
        }
    }
    onHeaderClick(e) {
        this.clicked.emit(e);
    }
    onHeaderTouchMove(e) {
        e.preventDefault();
        this.touchMoved.emit(e);
    }
    onHeaderTouchEnd(e) {
        e.preventDefault();
        this.touchEnded.emit(e);
    }
    ngOnInit() {
        this._container._addHeader(this);
    }
    ngOnDestroy() {
        this._container._removeHeader(this);
    }
}
SidebarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar-header',
                template: `
    <div class="ng-sidebar-header__content">
      <div class="ng-sidebar-header__wrapper">
        <ng-content></ng-content>
      </div>
    </div>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SidebarHeaderComponent.ctorParameters = () => [
    { type: SidebarComponent, decorators: [{ type: Optional }] }
];
SidebarHeaderComponent.propDecorators = {
    classNameSidebarHeader: [{ type: HostBinding, args: ['class.ng-sidebar-header',] }],
    className: [{ type: Input }, { type: HostBinding, args: ['class',] }],
    clicked: [{ type: Output }],
    touchMoved: [{ type: Output }],
    touchEnded: [{ type: Output }],
    onHeaderClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onHeaderTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    onHeaderTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }]
};

class SidebarContentComponent {
    constructor(_container, element) {
        this._container = _container;
        this.element = element;
        this.classNameSidebarContent = true;
        if (!this._container) {
            throw new Error('<ng-sidebar-content> must be inside a <ng-sidebar></ng-sidebar>.');
        }
    }
    ngOnInit() {
        this._container._addContent(this);
    }
    ngOnDestroy() {
        this._container._removeContent(this);
    }
}
SidebarContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar-content',
                template: `
    <ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SidebarContentComponent.ctorParameters = () => [
    { type: SidebarComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
SidebarContentComponent.propDecorators = {
    classNameSidebarContent: [{ type: HostBinding, args: ['class.ng-sidebar-content',] }],
    className: [{ type: Input }, { type: HostBinding, args: ['class',] }]
};

class SidebarAccordionContentComponent {
    constructor(_container) {
        this._container = _container;
        this.classNameSidebarAccordionContent = true;
        if (!this._container) {
            throw new Error('<ng-sidebar-accordion-content> must be inside a <ng-sidebar-accordion></ng-sidebar-accordion>.');
        }
    }
}
SidebarAccordionContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-sidebar-accordion-content',
                template: `
    <ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
SidebarAccordionContentComponent.ctorParameters = () => [
    { type: SidebarAccordionComponent, decorators: [{ type: Optional }] }
];
SidebarAccordionContentComponent.propDecorators = {
    classNameSidebarAccordionContent: [{ type: HostBinding, args: ['class.ng-sidebar-accordion-content',] }],
    className: [{ type: Input }, { type: HostBinding, args: ['class',] }]
};

class SidebarAccordionModule {
}
SidebarAccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    SidebarHeaderComponent,
                    SidebarContentComponent,
                    SidebarComponent,
                    SidebarAccordionContentComponent,
                    SidebarAccordionComponent,
                    SidebarSettingsComponent
                ],
                exports: [
                    SidebarHeaderComponent,
                    SidebarContentComponent,
                    SidebarComponent,
                    SidebarAccordionContentComponent,
                    SidebarAccordionComponent,
                    SidebarSettingsComponent
                ]
            },] }
];

class SidebarMouseTouchEventArgs {
}

/*
 * Public API Surface of ng-sidebar-accordion
 */

/**
 * Generated bundle index. Do not edit.
 */

export { SidebarAccordionComponent, SidebarAccordionContentComponent, SidebarAccordionModule, SidebarComponent, SidebarContentComponent, SidebarHeaderComponent, SidebarMouseTouchEventArgs, SidebarSettingsComponent };
//# sourceMappingURL=ng-sidebar-accordion.js.map
